#include <iostream>

using namespace std;

//1. Ime konstruktora isto kao i ime klase;
//2. Konstruktor je f-ja void tipa, samo sto rez. rec void ne pisemo
//3. Konstruktor je public f-ja/metoda

class Trougao {
private:
	int a;
	int b;
	int c;

	//Helpers

	bool mozeSeKonstruisati(int a, int b, int c) {
		return (a > 0 && b > 0 && c > 0 && a + b > c && b + c > a && c + a > b);
	}

	void konstruisiTrougao(int a, int b, int c) {
		if (this->mozeSeKonstruisati(a, b, c)) {
			this->a = a;
			this->b = b;
			this->c = c;

			this->trougao = true;
		}
		else {
			this->a = 0;
			this->b = 0;
			this->c = 0;

			this->trougao = false;
		}
	}

public:
	int trougao = false;

	//Constructors

	Trougao() {
		cout << "Konstruktor klase Trougao - PRAZAN" << endl;
		this->konstruisiTrougao(0, 0, 0);
	}

	Trougao(int a) {
		cout << "Konstruktor klase Trougao - JEDNAKOSTRANICAN" << endl;
		this->konstruisiTrougao(a, a, a);
	}

	Trougao(int a, int c) {
		cout << "Konstruktor klase Trougao - JEDNAKOKRAKI" << endl;
		this->konstruisiTrougao(a, a, c);
	}

	Trougao(int a, int b, int c) {
		cout << "Konstruktor klase Trougao - NEJEDNAKOSTRANICNI" << endl;
		this->konstruisiTrougao(a, b, c);
	}

	//Getters

	int obim() {
		return this->a + this->b + this->c;
	}

	bool jednakostranicni() {
		return (this->a == this->b && this->b == this->c);
	}

	bool jednakokraki() {
		return (this->a == this->b || this->b == this->c || this->c == this->a);
	}

	bool raznostrani() {
		return !(this->jednakokraki() || this->jednakostranicni());
	}
};




int main()
{

	Trougao defaulTrougao = Trougao();
	if (defaulTrougao.trougao) {
		cout << "JESTE TROUGAO" << endl;
	}
	else {
		cout << "NIJE TROUGAO" << endl;
	}


	Trougao jednakostranicni = Trougao(10);
	if (jednakostranicni.jednakostranicni()) {
		cout << "JESTE JEDNAKOSTRANICNI" << endl;
	}
	else {
		cout << "NIJE JEDNAKOSTRANICNI" << endl;
	}

	Trougao jednakokraki = Trougao(10, 3);
	if (jednakokraki.jednakokraki()) {
		cout << "JESTE JEDNAKOKRAKI" << endl;
	}
	else {
		cout << "NIJE JEDNAKOKRAKI" << endl;
	}

	Trougao raznostrani = Trougao(3, 4, 5);
	if (raznostrani.raznostrani()) {
		cout << "JESTE RAZNOSTRANI";
	}
	else {
		cout << "NIJE RAZNOSTRANI";
	}
}

---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

// KreiranjeKlase-Enkapsulacija-Konstruktor.cpp : This file contains the 'main' function. Program execution begins and ends there.
//

#include <iostream>
#include <string>

using namespace std;

//Definicija klase
// class ImeKlase {}

class Kurs {
	// Definisemo atribute i metode klase;
	// U skladu sa osobinom enkapsulacije, atributi i metodi mogu biti: 'private', 'public' ili 'protected';
	// Ukoliko se ne navede vrsta atributa/metoda po default-u su 'private'

	// PRIVATE (privatni) atributi i metode nisu dostupne van klase, tj. njima se moze pristupiti samo iz prostora klase
	// Atribute obicno definisemo kao 'private', jer tako sprecavamo njihovo citanje i azuriranje mimo za to definisanih metoda.
	// Od ovog nepisanog pravila naravno mozemo odstupiti ukoliko je neophodno. 
private:
	string naziv;

	int trajanje; // Trajanje kursa u nedeljama
	int casovaNedeljno;
	int tekuciCas;

	// PROTECTED (zasticeni) atributi i metode nisu dostupne izvan prostora klase osim kada im se pristupa iz izvedenih klasa (klasa naslednica) 
protected:
	string sifra;
	bool aktivan = true;

	// PUBLIC (javni) atributi i metode su dostupne izvan prostora klase.
	// Metode obicno definisemo kao 'public', mada nije nuzno (npr. mozemo kreirati neke pomocne metode radi preglednijeg koda koje ce biti pozivane iz drugih 'public' metoda).
	// Metoda == Funkcija
	// Metode u globalu (izuzimajuci konstruktore i destruktore) delimo u dve grupe: setter-i (postavljaju vrednosti atributa) i getter-i (vracaju vrednosti atributa).
public:
	// KONSTRUKTOR je specijalna metoda klase koja se uvek izvrsava prilikom inicijalizovanja/definisanja nekog objekta klase.
	// Ukoliko se ne definise, c++ compilier ce ga sam definisati (kreirace prazan konstruktor u kompajliranom kodu), tj. konstruktor klase postoji kreirali ga mi ili ne.
	// Ukoliko mi kreiramo konstruktor, onda Konstruktor metoda mora da zadovolji sledeca pravila:
	//	1. Ime konstruktor metode, tj konstruktora, je isto ime kao i ime klase;
	//	2. Tip konstruktora je 'void' ali to necemo pisati;
	//	3. Mora biti definisan kao 'public' metoda
	// Mozemo da imamo vise konstruktora sa razlicitim ulaznim parametrima.
	// KONSTRUKTOR je specijalna metoda koja nam garantuje da ce se odredjeni kod izvrsiti uvek kada kreiramo neki objekat klase, 
	// sto nam moze biti od velike koristi - npr. mozemo da postavimo zeljene pocetne vrednosti atributa.

	// Konstruktor bez ulaznih parametara - "prazan" konstruktor
	Kurs() {
		this->naziv = "";
		this->sifra = "";

		this->trajanje = 0;
		this->casovaNedeljno = 0;

		this->aktivan = false;

		// Pokazivac 'this' je interni pokazivac klase. Koristimo ga za pozivanje atributa i metoda klase iz nje same.
		// Na taj nacin znamo da se uvek obracamo atributima i metodama klase,
		// tj. izbegavamo nedoumice ukoliko neku od ulaznih ili internih promenljivih f-ja nazovemo istim imenom kao i atribut klase.
	}

	// Konstruktor sa ulaznim parametrima
	Kurs(string sifra, string naziv, int trajanje, int casovaNedeljno) {
		// Primer dodeljivanja vrednosti atributima koriscenjem pokazivaca 'this'
		this->sifra = sifra;
		this->naziv = naziv;

		this->trajanje = trajanje;
		this->casovaNedeljno = casovaNedeljno;
	}

	// Setters - obicno su tipa 'void'

	void setNaziv(string naziv) {
		this->naziv = naziv;
	}

	void setSifra(string sifra) {
		this->sifra = sifra;
	}

	void setTrajanje(int trajanje) {
		if (trajanje > 0 && trajanje <= 52)
			this->trajanje = trajanje;
		else {
			this->trajanje = 0;
		}
	}

	void setCasovaNedeljno(int casovaNedeljno) {
		if (casovaNedeljno > 0 && casovaNedeljno <= 10)
			this->casovaNedeljno = casovaNedeljno;
		else {
			this->casovaNedeljno = 0;
		}
	}

	void setStatus(bool aktivan) {
		this->aktivan = aktivan;
	}

	// Getters - obicno imaju povratnu vrednost, tj. nisu tipa 'void'

	string getNaziv() {
		return this->naziv;
	}

	string getSifra() {
		return this->sifra;
	}

	int getTrajanje() {
		return this->trajanje;
	}

	int getCasovaNedeljno() {
		return this->casovaNedeljno;
	}

	bool getStatus() {
		return this->aktivan;
	}

	int getUkupnoCasova() {
		return this->casovaNedeljno * this->trajanje;
	}

	string stampa() {
		string result = "";
		result.append("KURS:\n");
		result.append(this->getSifra());
		result.append(" - ");
		result.append(this->getNaziv());
		result.append(", ukupno casova: ");
		result.append(to_string(this->getUkupnoCasova()));
		if (this->getStatus()) {
			result.append(", AKTIVAN");
		}
		else {
			result.append(", PASIVAN");
		}
		result.append("\n--------------------------------\n");
		return result;
	}
};

int main()
{
	Kurs matematika = Kurs();
	cout << matematika.stampa() << endl;

	matematika.setNaziv("MATEMATIKA");
	matematika.setSifra("MAT");
	matematika.setTrajanje(37);
	matematika.setCasovaNedeljno(4);
	matematika.setStatus(true);
	cout << matematika.stampa() << endl;

	Kurs fizika = Kurs("FIZ", "FIZIKA", 37, 2);
	cout << fizika.stampa() << endl;

	return 0;
}

---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

#include <iostream>
#include <string>

using namespace std;

class Igrac
{
private:
	string imeIgraca;

	//Staticki atribut - OSOBINE:
	// - atribut klase, deljen izmedju svih kreiranih objekata (postoji samo jedna kopija statickog atributa bez obzira koliko objekata klase kreirali)
	// - prostor statickog atributa je prostor klase
	// - inicijalizuje se na 0 kada je kreiran prvi objekat klase (osim ako nema druge inicijalizacije u prostoru klase)
	// - vidljiv/dostupan je samo kao atribut klase, ali postoji dokle god postoji i program (cak i kada ne postoji ni jedan objekat).
	static int brojIgraca;

public:
	//Constructors
	Igrac() {
		this->setImeIgraca("JOHN DOE");

		this->brojIgraca++;
	}

	Igrac(string imeIgraca) {
		this->setImeIgraca(imeIgraca);

		this->brojIgraca++;
	}

	//Destructor
	//Destruktor je specijalna metoda klase koja se uvek izvrsava prilikom brisanja objekta klase.
	// Ukoliko se ne definise, c++ compilier ce ga sam definisati.
	// Ukoliko mi kreiramo destruktor, onda Destruktor metoda mora da zadovolji sledeca pravila:
	//	1. Ime destruktor metode, tj destruktora, je isto ime kao i ime klase pri cemu je obavezno dodati prefiks `~`;
	//	2. Tip destruktora je 'void' ali to necemo pisati;
	//	3. Mora biti definisan kao 'public' metoda
	// Mozemo da imamo samo jedan destruktor.
	// DESTRUKTOR je specijalna metoda koja nam garantuje da ce se odredjeni kod izvrsiti uvek kada se brise neki objekat klase, 
	// sto nam moze biti od velike koristi - npr. mozemo da azuriramo staticke atribute.
	// Ukoliko klasa poseduje atribute koji su pokazivace onda je jako pozeljno (preporuceno) pisanje destruktora 
	// u kojem bismo izvrsili oslobadjanje dinamicke memorije na koju ti atributi pokazuju (u suprotnom dinamicka memorija ce ostati zauzeta a podatke o adresi necemo imati)
	~Igrac() {
		cout << "Destruktor klase se izvrsio kada je igrac " << this->getImeIgraca() << " izbrisan." << endl;
		this->brojIgraca--;
	}

	//Setters

	void setImeIgraca(string imeIgraca) {
		this->imeIgraca = imeIgraca;
	}

	//Getters

	string getImeIgraca() {
		return this->imeIgraca;
	}

	//Staticka metoda - OSOBINE
	// - to je metoda klase koja je nezavisna od njenih objekata;
	// - mozemo je pozivati kao metodu klase (tj iz prostora klase) cak i kada nijedan objekat klase nije definisan
	// - staticka metoda moze pristupiti samo statickim atributima i drugim statickim metodama (i naravno drugim f-jama izvan klase ukoliko postoje)
	// - prostor staticke metode je prostor klase (mozemo je pozivati i preko prostora klase, ali i preko objekta kao i svaku drugu metodu ukoliko je public)
	// - "this" pokazivac ne mozemo koristiti u okviru staticke metode (jer je "this" pokazivac koji pripada objektima, a staticka metoda je metoda na nivou klase a ne objekta kao druge metode)
	static int brojAktivnihIgraca() {
		return brojIgraca;
	}

};

//Staticka promenljiva - postavljanje inicijalne vrednosti
//Inicijalizacija se ne moze izvrsiti unutar klase!
//Ali moze se izvrsiti izvan deklaracije klase (npr. u glavnom programu), pri cemu se mora navesti prostor klase.
//Ukoliko se ne izvrsi njena inicijalizacija, onda po default-u dobija vrednost 0;
int Igrac::brojIgraca = 0;

int main() {

	Igrac* i1 = new Igrac();

	//Staticku metodu mozemo pozivati direktno preko prostora klase
	cout << "Staticka metoda brojAktivnihIgraca() pozvana iz prostora klase: " << Igrac::brojAktivnihIgraca() << endl;
	//Ali i kao metodu nekog njenog objekta
	cout << "Staticka metoda brojAktivnihIgraca() pozvana preko objekta klase: " << i1->brojAktivnihIgraca() << endl;

	Igrac* i2 = new Igrac("POKAZIVAC NA OBJEKAT");
	cout << i2->brojAktivnihIgraca() << endl; //Pozivanje staticke metode iz nekog objekta klase objekta

	delete i1;
	i1 = nullptr;

	cout << "\nBroj aktivnih igraca: " << Igrac::brojAktivnihIgraca() << endl;

	return 0;
}
